---
description: 并发索引
---

# task#4 Concurrent index

## 要求

最后，修改B+树实现，使其安全地支持并发操作。你应该使用课堂和教科书中描述的latch crabbing技术。遍历索引的线程应根据需要获取B+树页面上的锁，以确保安全的并发操作，并应在确定这样做是安全的时候尽快释放父页上的锁。

建议你首先将FetchPageBasic更改为FetchPageWrite和FetchPageRead来完成此任务，具体取决于你是要访问具有读取权限还是写入权限的页面。然后修改你的实现，以根据需要获取和释放读写锁存器，以实现latch crabbing算法。

注意：切勿在单个线程中两次获取相同的读锁定。这可能会导致死锁。

## 蟹型协议 crabbing protocol

* 当搜索一个KV时，蟹型协议首先对在共享模式的根节点加锁。当往下遍历树时，它请求一个孩子节点的共享锁以遍历更远。在获取孩子节点的锁后，它释放父节点的锁。它重复该步骤知道抵达一个叶子节点。
*   当插入或删除一个KV对时，蟹型协议采取以下步骤：

    1. 它遵循类似搜索的规则，直到抵达目标叶子节点。它获取并释放的只有共享锁。
    2. 它对叶子节点在排他锁模式加锁，并执行插入和删除KV对操作。
    3. 如果它需要分裂或者合并，或者在兄弟节点之间执行重分配KV，蟹型协议对节点的父节点加排他锁。在执行完这些行为之后，它释放节点及兄弟节点的锁。
    4. 如果父节点需要分裂、合并或者KV对的重分配，蟹型协议会锁住父节点，然后以同样的方式往后执行分裂、合并和重分配。否则，它释放父节点的锁。

    该协议取名来自于螃蟹往它的侧边行走，往同一方向移动脚，然后移动另一只脚，循环往复。加锁的过程类似于此（父节点加锁，子节点加锁，父节点解锁）。

一旦某个操作释放了某个节点的锁，其他操作能够操作该节点。这里存在一个产生死锁的情况，当搜索操作往下遍历树，同时分裂、合并和重分配往上遍历树。系统可以通过在释放操作持有的锁之后，从根节点重新开始搜索操作来轻松处理这种死锁情况。

持续时间较短的锁，而不是以两阶段方式持有的锁，通常被称为latches。在数据库内部，latches被用于实现共享数据的互斥访问。他们是一种短期的锁，用于保护共享资源，以避免并发访问时的数据不一致问题。在上述情况下，锁以一种不保证在插入或者删除操作期间互斥的方式被持有，但是索引操作的执行结果是可串行化的。这是因为在内存数据库中，索引操作的执行速度非常快，因此可以接受在执行操作时以比较粗的粒度进行锁定，例如可以使用单个latch锁定整个索引，执行操作后再释放锁。这种锁定方式的开销小，可以弥补稍微降低的并发性，并提高整体性能。

## 实现思想

* 默认会有冲突发生，因此事先加锁。（悲观锁）
* 当子树发生分裂或者合并也不会影响上层，可释放该节点及祖先节点的锁。
* 查找：
  1. 读写锁
  2. 先获取孩子节点的锁，释放自身的锁
* 插入：
  1. 排他锁（写锁）
  2. 当前节点未满，安全
*   删除：

    1. 排他锁（写锁）
    2. 删除后，节点至少半满（安全）



